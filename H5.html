<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tudatos Kamra Analízis modell</title>
    <style>
        body {
            font-family: "Times New Roman", Times, serif;
            line-height: 1.5;
            color: #000;
            background-color: #fff;
        }
        

        h1 {
            text-align: center;
            font-size: 18pt;
            font-weight: bold;
        }

        /* Táblázat stílusok */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        th, td {
            text-align: left;
            vertical-align: top;
        }

        /* Dátum jobbra igazítása */
        .date-right {
            text-align: right;
        }

        /* Szövegformázás */
        h2 {
            font-size: 14pt;
        }

        h3 {
            font-size: 12pt;
        }

        ul {
            list-style-type: disc;
        }

        /* Kód blokk stílusok */
        pre {
            background-color: #f5f5f5;
            overflow-x: auto;
            font-family: Consolas, "Courier New", monospace;
            font-size: 10pt;
        }
    </style>
</head>
<body>

    <div class="header-info">
        <p>Csoport neve: Bitangok</p>
        <p>Feladat sorszáma: H4</p>
        <p>Feladat címe: Software követelmény specifikáció</p>
    </div>

    <h1>Tudatos Kamra Analízis modell</h1>

    <div class="instructor">
        <p>Gyakorlatvezető:</p>
        <p>Tompa Tamás</p>
    </div>

    <p>Csoport tagok:</p>
    <table>
        <tbody>
            <tr>
                <td>Molnár Vajk Boldizsár</td>
                <td>HJLXA4</td>
                <td>vajk.boldizsar.molnar@student.uni-miskolc.hu</td>
            </tr>
            <tr>
                <td>Balogh Lili Dorka</td>
                <td>EXTVJC</td>
                <td>lili.dorka.balogh@student.uni-miskolc.hu</td>
            </tr>
            <tr>
                <td>Molnár Márk Patrik</td>
                <td>GMPOCB</td>
                <td>mark.patrik.molnar@student.uni-miskolc.hu</td>
            </tr>
            <tr>
                <td>Kriston Zalán</td>
                <td>E3K8G9</td>
                <td>zalan.kriston@student.uni-miskolc.hu</td>
            </tr>
            <tr>
                <td>Kádár Balázs</td>
                <td>CFW04U</td>
                <td>balazs.kadar@student.uni-miskolc.hu</td>
            </tr>
        </tbody>
    </table>

    <div class="date-right">
        2025.12.5.
    </div>

    <p>Történet</p>
    <table>
        <thead>
            <tr>
                <th>Dátum</th>
                <th>Verzió</th>
                <th>Leírás</th>
                <th>Szerző</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>2025.10.17.</td>
                <td>0.1</td>
                <td>Vízió kész a 3. pontig</td>
                <td>Molnár Vajk</td>
            </tr>
            <tr>
                <td>2025. 11. 02.</td>
                <td>0.2</td>
                <td>Vízió befejezve</td>
                <td>Molnár Vajk</td>
            </tr>
            <tr>
                <td>2025.11.19.</td>
                <td>0.3</td>
                <td>Use-case diagramm</td>
                <td>Molnár Vajk</td>
            </tr>
            <tr>
                <td>2025.12.02.</td>
                <td>0.4</td>
                <td>Kezdeti osztálydiagramm</td>
                <td>Molnár Vajk</td>
            </tr>
            <tr>
                <td>2025.12.05.</td>
                <td>0.5</td>
                <td>Teljes osztálydiagram</td>
                <td>Molnár Vajk</td>
            </tr>
        </tbody>
    </table>

    <hr>

    <h2>H5: Objektum tervezés és Implementáció</h2>

    <h3>1. Rendszer vezérlésének kidolgozása</h3>
    <p>A vezérlésre vonatkozóan különböző típusú objektumok vannak, például aktív, passzív, és vezérlő objektumok. [cite: 14]</p>

    <h4>Aktív objektumok</h4>
    <p>Az aktív objektumok azok, amelyek közvetlenül befolyásolják a rendszer működését, és amelyek folyamatosan elvégzik a feladatokat a rendszerben. Ezek az objektumok rendelkeznek saját logikával. [cite: 16, 17]</p>
    <ul>
        <li><strong>Felhasználó (User):</strong> Mivel a felhasználó az alkalmazás központi szereplője, és képes különböző műveleteket végrehajtani (bevásárlólisták létrehozása, barátok hozzáadása stb.), aktív objektumként szerepel. [cite: 18, 19]</li>
        <li><strong>Bolt (Store):</strong> A boltok is aktív objektumok, mert képesek interakcióba lépni a felhasználókkal és promóciókat kezelni. [cite: 20, 21]</li>
        <li><strong>Akció (Promotion):</strong> Az akciók aktívak, mivel kapcsolatba lépnek a boltokkal, és végrehajtják a kedvezményeket. [cite: 22, 23]</li>
    </ul>

    <h4>Passzív objektumok</h4>
    <p>A passzív objektumok azok, amelyek nem végeznek aktív műveleteket, hanem egyszerűen tárolják az adatokat vagy információkat, amiket az aktív objektumok használnak. [cite: 25]</p>
    <ul>
        <li><strong>Bevásárlólista (ShoppingList):</strong> A bevásárlólisták adatokat tárolnak (termékek), de nem végeznek el saját műveleteket. [cite: 26, 27]</li>
        <li><strong>Termék (Product):</strong> A termékek adatokat tartalmaznak, de nem tartalmaznak üzleti logikát. [cite: 28, 29]</li>
        <li><strong>Készlet (Inventory):</strong> A készlet az otthoni termékeket tárolja, de nem hajt végre aktív műveleteket. [cite: 30, 31]</li>
        <li><strong>Recept (Recipe):</strong> A receptek csak adatokat (összetevőket, elkészítési időt) tárolnak. [cite: 32, 33]</li>
        <li><strong>Barát (Friend):</strong> A barátok listája tárolja a felhasználói kapcsolatokat, de nem tartalmaz üzleti logikát. [cite: 34, 35]</li>
    </ul>

    <h4>Vezérlő objektumok</h4>
    <p>A vezérlő objektumok kulcsszerepet játszanak az egész rendszer működésében, mivel ők irányítják az aktív és passzív objektumok közötti interakciókat. [cite: 37]</p>
    <ul>
        <li><strong>LocationService:</strong> A helymeghatározás szolgáltatás aktív vezérlő objektum, mivel képes lekérdezni a közeli boltokat és promóciókat, és interakcióba lépni a boltokkal és a felhasználóval. [cite: 38, 39]</li>
        <li><strong>NutritionTracker:</strong> A táplálkozási nyomkövető egy vezérlő objektum, amely nyomon követi a felhasználó napi étkezését és tápanyagait. [cite: 40, 41]</li>
    </ul>

    <h3>2. Osztályok közötti kapcsolatok implementálása</h3>
    <p>A rendszerben az osztályok közötti kapcsolatoknak tükrözniük kell a valóságos működést. [cite: 43]</p>
    
    <p><strong>2.1. Felhasználó és bevásárlólista kapcsolata:</strong> A Felhasználó (User) és a Bevásárlólista (ShoppingList) között egy 1:N kapcsolat áll fenn, mivel egy felhasználónak több bevásárlólistája lehet. Az implementálásban a User osztály egy <code>List&lt;ShoppingList&gt;</code> attribútummal tárolja a bevásárlólistákat. [cite: 44, 45, 46]</p>
    
    <p><strong>2.2. Felhasználó és Barát kapcsolata:</strong> A Felhasználó (User) és a Barát (Friend) között szintén 1:N kapcsolat van. A User osztály tartalmazhat egy listát a barátok azonosítóival (<code>List&lt;Friend&gt;</code>). [cite: 47, 48, 49]</p>
    
    <p><strong>2.3. Bevásárlólista és Termék kapcsolata:</strong> A Bevásárlólista (ShoppingList) és a Termék (Product) között 1:N kapcsolat van. A ShoppingList osztályban a termékek egy listában tárolódnak (<code>List&lt;Product&gt;</code>). [cite: 50, 51]</p>
    
    <p><strong>2.4. Bolt és Akció kapcsolata:</strong> A Bolt (Store) és az Akció (Promotion) között 1:N kapcsolat van. A Store osztály egy listát (<code>List&lt;Promotion&gt;</code>) tartalmaz. [cite: 52, 53]</p>
    
    <p><strong>2.5. Recept és Termék kapcsolata:</strong> A Recept (Recipe) és a Termék (Product) között 1:N kapcsolat áll fenn, mivel egy recept több összetevőt is tartalmazhat. A Recipe osztály a hozzávalókat (<code>List&lt;Product&gt;</code>) tárolja. [cite: 54, 55, 56]</p>
    
    <p><strong>2.6. LocationService és Bolt kapcsolata:</strong> A LocationService osztály kapcsolódik a Store osztályhoz, mivel a felhasználó helyzetétől függően kell keresni a közeli boltokat. Ez egy N:M kapcsolatot jelent. [cite: 57, 58, 59]</p>

    <h3>3. Osztályok csomagokba szervezése</h3>
    <ul>
        <li><strong>3.1. User Package:</strong> User osztály, Friend osztály [cite: 61, 62]</li>
        <li><strong>3.2. Shopping Package:</strong> ShoppingList osztály, Product osztály, Inventory osztály [cite: 63, 64]</li>
        <li><strong>3.3. Recipe Package:</strong> Recipe osztály [cite: 65, 66]</li>
        <li><strong>3.4. Store Package:</strong> Store osztály, Promotion osztály, LocationService osztály [cite: 67, 68]</li>
        <li><strong>3.5. Nutrition Package:</strong> NutritionTracker osztály [cite: 69, 70]</li>
    </ul>

    <h3>4. Implementáció</h3>
    <p>A szoftver implementációja során az osztályok közötti kommunikáció kulcsfontosságú. A megfelelő getter és setter metódusok mellett a kommunikációt támogató üzleti logikai metódusok megtervezése az egyik legfontosabb lépés. [cite: 72]</p>

    <h4>Skeleton</h4>
    <p>A skeleton egy alapvető, minimális struktúra, amelyben az osztályok és metódusok már definiálva vannak, de azok implementációi (logikái) még nem teljesek. [cite: 73, 74]</p>

    <p>Példa a ShoppingList skeletonjára: [cite: 75]</p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class ShoppingList {
    private List&lt;ShoppingListItem&gt; items;

    public ShoppingList() {
        this.items = new ArrayList&lt;&gt;();
    }

    public void addItem(String itemName, int quantity) {
        items.add(new ShoppingListItem(itemName, quantity));
    }

    public List&lt;ShoppingListItem&gt; getItems() {
        return items;
    }

    public void printList() {
        System.out.println("Shopping List:");
        for (ShoppingListItem item : items) {
            System.out.println(item.getName() + " - " + item.getQuantity());
        }
    }
}

class ShoppingListItem {
    private String name;
    private int quantity;

    public ShoppingListItem(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    public String getName() { return name; }
    public int getQuantity() { return quantity; }
}</code></pre>
    <p>Példa a User skeletonjára: [cite: 106]</p>
<pre><code>public class User {
    private String name;
    private String email;
    private ShoppingList activeShoppingList;

    public User(String name, String email) {
        this.name = name;
        this.email = email;
        this.activeShoppingList = new ShoppingList();
    }

    public String getName() { return name; }
    public String getEmail() { return email; }
    public ShoppingList getActiveShoppingList() { return activeShoppingList; }
}</code></pre>
    <p>Példa a Recipe skeletonjára: [cite: 120]</p>
<pre><code>import java.util.HashMap;
import java.util.Map;

public class Recipe {
    private String name;
    private Map&lt;String, Integer&gt; ingredients;

    public Recipe(String name) {
        this.name = name;
        this.ingredients = new HashMap&lt;&gt;();
    }

    public void addIngredient(String ingredient, int quantity) {
        ingredients.put(ingredient, quantity);
    }

    public Map&lt;String, Integer&gt; getIngredients() {
        return ingredients;
    }

    public void printRecipe() {
        System.out.println("Recipe: " + name);
        for (Map.Entry&lt;String, Integer&gt; entry : ingredients.entrySet()) {
            System.out.println("- " + entry.getKey() + ": " + entry.getValue());
        }
    }
}</code></pre>
    <h4>Prototípus</h4>
    <p>A prototípus egy olyan fejlesztési szakasz, amely az alkalmazás fő funkcióinak egyszerűsített, kezdeti verzióját tartalmazza. Az alábbi kódok már tartalmazzák a törlési és frissítési logikát is. [cite: 143, 144, 145]</p>
    
    <p>Bővített logika (ShoppingList): [cite: 146]</p>
<pre><code>public void removeItem(String itemName) {
    for (ShoppingListItem item : items) {
        if (item.getName().equals(itemName)) {
            items.remove(item);
            System.out.println(itemName + " has been removed.");
            return;
        }
    }
    System.out.println(itemName + " not found.");
}

public void updateItemQuantity(String itemName, int newQuantity) {
    for (ShoppingListItem item : items) {
        if (item.getName().equals(itemName)) {
            item.setQuantity(newQuantity);
            System.out.println(itemName + " updated to " + newQuantity);
            return;
        }
    }
    System.out.println(itemName + " not found.");
}</code></pre>
    <h3>5. Tesztelési terv</h3>
    <p><strong>1. Tesztelési Célok:</strong> Tesztelni kell, hogy a rendszer képes új tételt hozzáadni, eltávolítani és frissíteni a tétel mennyiségét. Ellenőrizni kell a lista helyes megjelenítését, különös figyelmet fordítva az üres listára és a hibakezelésre. [cite: 168, 169, 170]</p>
    <p><strong>2. Tesztelési Típusok:</strong> Funkcionális tesztelés, Hibakezelés tesztelése, Integrációs tesztelés. [cite: 171, 172]</p>
    
    <p><strong>3. ShoppingList tesztelése (JUnit):</strong> [cite: 173]</p>
<pre><code>import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.util.List;

public class ShoppingListTest {
    private ShoppingList shoppingList;

    @BeforeEach
    public void setUp() {
        shoppingList = new ShoppingList();
    }

    @Test
    public void testAddItem() {
        shoppingList.addItem("Apples", 3);
        List&lt;ShoppingListItem&gt; items = shoppingList.getItems();
        assertEquals(1, items.size());
        assertEquals("Apples", items.get(0).getName());
    }

    @Test
    public void testRemoveItem() {
        shoppingList.addItem("Bananas", 5);
        shoppingList.removeItem("Bananas");
        assertTrue(shoppingList.getItems().isEmpty());
    }

    @Test
    public void testUpdateItemQuantity() {
        shoppingList.addItem("Milk", 1);
        shoppingList.updateItemQuantity("Milk", 3);
        assertEquals(3, shoppingList.getItems().get(0).getQuantity());
    }

    @Test
    public void testAddEmptyItem() {
        shoppingList.addItem("", 0);
        // Validációs logika ellenőrzése
    }
}</code></pre>
    </body>
</html>
